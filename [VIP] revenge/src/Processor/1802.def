// ******************************************************************************************************************
// ******************************************************************************************************************
//
//											  1802 Processor Definition
//
// ******************************************************************************************************************
// ******************************************************************************************************************

// ******************************************************************************************************************
//
// @R 	register number (in decimal) lower 4 bits
// @H 	"R"+register number (in hex) lower 4 bits
// @E 	EFlag number (lower 2 bits + 1)
// @P 	lower 3 bits
//
// ******************************************************************************************************************

// ******************************************************************************************************************
//													General Macros
// ******************************************************************************************************************

:static BYTE8 	D,DF,IE,Q,T,P,X,temp8;															// 8 bit values
:static WORD16 	R[16],Cycles,temp16;															// 16 bit values

:#define FETCH()	READ(R[P]++)																// 8 bit fetch.
:#define RESET() 	{ Q = 0;IE = 1; X = P = R[0] = 0; DF &= 1; }								// Reset CPU/Valid values.

// ******************************************************************************************************************
//													Memory Reference
// ******************************************************************************************************************

01-0F 	"LDN @H"	D = READ(R[@R])															
40-4F 	"LDA @H"	D = READ(R[@R]++)
F0 		"LDX"		D = READ(R[X])
72 		"LDXA"		D = READ(R[X]++)
F8 		"LDI .1"	D = FETCH()
50-5F 	"STR @H"	WRITE(R[@R],D)
73 		"STXD"		WRITE(R[X]--,D)

// ******************************************************************************************************************
//													Register Operations
// ******************************************************************************************************************

10-1F 	"INC @H"	R[@R]++
20-2F 	"DEC @H"	R[@R]--
60		"IRX"		R[X]++
80-8F	"GLO @H"	D = R[@R]
A0-AF 	"PLO @H"	R[@R] = (R[@R] & 0xFF00) | D
90-9F 	"GHI @H"	D = R[@R] >> 8
B0-BF 	"PHI @H"	R[@R] = (R[@R] & 0x00FF) | (((WORD16)D) << 8)

// ******************************************************************************************************************
//													   Logic Operations
// ******************************************************************************************************************

F1 		"OR"		D = D | READ(R[X])
F9 		"ORI .1"	D = D | FETCH()
F3		"XOR"		D = D ^ READ(R[X])
FB 		"XRI .1"	D = D ^ FETCH()
F2 		"AND"		D = D & READ(R[X])
FA 		"ANI .1"	D = D & FETCH()

F6 		"SHR"		DF = D & 1;D = D >> 1
76 		"RSHR"		temp8 = D;D = (D >> 1) | (DF << 7);DF = temp8 & 1
FE 		"SHL"		DF = D >> 7;D = D << 1
7E 		"RSHL"		temp8 = D;D = (D << 1) | DF;DF = temp8 >> 7

// ******************************************************************************************************************
//												Arithmetic Operations
// ******************************************************************************************************************

:#define ADD(n1,n2,df)	temp16 = (n1)+(n2)+(df);D = temp16;DF = (temp16 >> 8) & 1
:#define SUB(n1,n2,df) 	ADD(n1,(n2) ^ 0xFF,df)

F4 		"ADD"		ADD(D,READ(R[X]),0)
FC 		"ADI .1"	ADD(D,FETCH(),0)
74 		"ADC"		ADD(D,READ(R[X]),DF)
7C 		"ADCI .1"	ADD(D,FETCH(),DF)

F5 		"SD"		SUB(READ(R[X]),D,1)
FD 		"SDI .1"	SUB(FETCH(),D,1)
75 		"SDB"		SUB(READ(R[X]),D,DF)
7D 		"SDBI .1"	SUB(FETCH(),D,DF)

F7 		"SM"		SUB(D,READ(R[X]),1)
FF 		"SMI .1"	SUB(D,FETCH(),1)
77 		"SMB"		SUB(D,READ(R[X]),DF)
7F 		"SMBI .1"	SUB(D,FETCH(),DF)

// ******************************************************************************************************************
//													Short Branch
// ******************************************************************************************************************

:#define BRANCH() 	{ R[P] = (R[P] & 0xFF00) | READ(R[P]); }
:#define SKIP() 	{ R[P]++; }

30 		"BR .1"		BRANCH()
31 		"BQ .1"		if (Q != 0) BRANCH() else SKIP()
32 		"BZ .1"		if (D == 0) BRANCH() else SKIP()
33 		"BDF .1"	if (DF != 0) BRANCH() else SKIP()
34-37 	"B@E .1"	if (EFLAG@E() != 0) BRANCH() else SKIP()

39 		"BNQ .1"	if (Q == 0) BRANCH() else SKIP()
3A 		"BNZ .1"	if (D != 0) BRANCH() else SKIP()
3B 		"BNF .1"	if (DF == 0) BRANCH() else SKIP()
3C-3F 	"BN@E .1"	if (EFLAG@E() == 0) BRANCH() else SKIP()

// ******************************************************************************************************************
//													Long Branch
// ******************************************************************************************************************

:#define LBRANCH() 	{ R[P] = (READ(R[P]) << 8) | READ(R[P]+1);Cycles++; }
:#define LSKIP() 	{ R[P] += 2; }

C0 		"LBR .2"	LBRANCH()
C1 		"LBQ .2"	if (Q != 0) LBRANCH() else LSKIP()
C2 		"LBZ .2"	if (D == 0) LBRANCH() else LSKIP()
C3 		"LBDF .2"	if (DF != 0) LBRANCH() else LSKIP()
C9 		"LBNQ .2"	if (Q == 0) LBRANCH() else LSKIP()
CA 		"LBNZ .2"	if (D != 0) LBRANCH() else LSKIP()
CB 		"LBNF .2"	if (DF == 0) LBRANCH() else LSKIP()

// ******************************************************************************************************************
//													Skips
// ******************************************************************************************************************

38 		"SKP"		SKIP()
C8 		"LSKP"		LSKIP()
CD 		"LSQ"		if (Q != 0) LSKIP()
CE 		"LSZ"		if (D == 0) LSKIP()
CF 		"LSDF"		if (DF != 0) LSKIP()
C5 		"LSNQ"		if (Q == 0) LSKIP()
C6 		"LSNZ"		if (D != 0) LSKIP()
C7 		"LSNF"		if (DF == 0) LSKIP()
CC 		"LSIE"		if (IE != 0) LSKIP()

// ******************************************************************************************************************
//													Control Instructions
// ******************************************************************************************************************

:#define INTERRUPT() if (IE != 0) { T = (X << 4) | P; X = 2;P = 1;IE = 0; }
:#define RETURN()	{ temp8 = READ(R[X]);R[X]++;P = temp8 & 0xF;X = temp8 >> 4; }

00		"IDL"		Cycles += 1000
C4 		"NOP"		{}
D0-DF 	"SEP @H"	P = @R
E0-EF 	"SEX @H"	X = @R
7B 		"SEQ"		OUTPORTQ(Q,1);Q = 1
7A 		"REQ"		OUTPORTQ(Q,0);Q = 0
78		"SAV"		WRITE(R[X],T)
79 		"MARK"		T = (X << 4) | P;WRITE(R[2],T);X = P;R[2]--
70		"RET"		RETURN();IE = 1
71 		"DIS"		RETURN();IE = 0

// ******************************************************************************************************************
//												Input/Output Byte Transfer
// ******************************************************************************************************************

61-67 	"OUT @P"	OUTPORT@P(READ(R[X]));R[X]++
69-6F 	"INP @P"	D = INPORT@P();WRITE(R[X],D)

